# Alerting

This program changes the color of your Hyprland windows' borders depending on your battery level.

To do so, the program is either called periodically at definite time intervals (systemd), or is called when your battery level decreases (using udev).

## Requirements

To use this program, you must have the following *things* installed:

 1. Hyprland (*obviously*)
 2. [GCC](https://archlinux.org/packages/core/x86_64/gcc/)

If the program cannot find a specific command, you can install it (`bc` for example).

## Configuring Hyprland

For this program to work, you have to source the `alerting.conf` file in your Hyprland config.

```conf
# ~/.config/hypr/hyprland.conf

source=~/.config/hypr/alerting.conf # Source the alerting file
...
```

This `alerting.conf` file will be entirely modified by this script, don't put anything important in there.

> [!WARNING]
>
> For this to work, you have to remove or comment out the `col.active_border` property in the `general` section of your config. I'm not sure how Hyprland handles duplicate properties, but I'm sure that'll lead to unnecessary problems.

## Configuring this Program

First of all, you should run the `./alerting.sh --compile` command in this directory to compile the *precompiler*. Whats the precompiler? You'll see later. Now you should take a look at the `alerting.ini` configuration file, it contains information about every single property.

> [!NOTE]
>
> If you're wondering why the final category in the configuration file is ambiguous, it is because it should not be touched if you don't have a good understanding of how the program works. The way this program functions will be described in a later section.

If you want to test what the color of your border will be at a certain percentage, you can use the `alerting.sh` script located in the same directory as this markdown file. You can call the command `./alerting.sh --run=...` to run the border changing script at a battery value of your choice. Read `./alerting.sh --help` and the *Main Script* section for more information.

> [!NOTE]
>
> After modifying your settings, if you don't notice a change, run `./alerting.sh --precompile`. See the *Precompiler* section.

### Modifying Paths

This programs contains a few paths that you have to change for the program to function. Here is the list of paths in the list and what you should change it to:

> [!NOTE]
>
> Name of the files are relative to the `alerting/` directory (this one)

 1. `script.sh` -> Absolute path of the `alerting.conf` file in your Hyprland configuration;
 2. `script.sh` -> Absolute path of the script generated by the precompiler;
 3. `reference.sh` -> Absolute path of the `script.sh` script;
 4. `systemd/alerting.service` -> Absolute path of the `reference.sh` script;
 5. `udev/alerting.rules` -> Absolute path of the `reference.sh` script.

If you are wondering where to see these files, type `ls`.

### Configuring Periodic/Event Calls

There are two ways to run this script automatically: using udev or using systemd. I've ran into some problems with udev, but if you get it working, it's undoubtedly the better option.

Systemd is used to call the script periodically on distinct time intervals (like every minute), while udev is used to call the script when the battery percentage changes. I would recommend you try to use udev first, and if you don't get it working, switch to systemd.

#### Setting up *udev*

*udev* generally works in this way: it triggers events based on actions done using rules. These rules should be located in the `/etc/udev/rules.d/` directory.

There is already a rule written for this stored in the `udev` folder, but I did not get it working as events were not getting called most of the time. You can simply move it with this command: `sudo mv udev/alerting.rules /etc/udev/rules.d/`. Then you can reload your udev rules with this command: `sudo udevadm control --reload-rules`.

#### Setting up *systemd*

*systemd* works with services that I will not try to explain as I do not know enough about it. Services are located in the `/etc/systemd/system` directory.

There is already a service that works on a timer stored in the `systemd` folder. You can simply move it with this command: `sudo mv systemd/* /etc/systemd/system/`. Then you can reload services using this command: `sudo systemctl daemon-reload`; you can enable your timer with this command: `sudo systemctl enable alerting.timer`; you can directly start the timer with this command: `sudo systemctl start alerting.timer`. Later you can use `sudo systemctl status alerting.timer` to get information about the timer. Once the timer is started, you can use `sudo systemctl list-timers` to see how much time there is left until the next call.

## How to Program Functions

I don't think my code is bad (I don't think its good either), so you might aswell open the files in your favorite text editor and look at whats happening yourself.

### Color Interpolation

The border goes from a color to another smoothly, how? The color in the settings is in its component R, G and B values which simply are numbers. The interpolation (the smooth change from a point to another) is then calculated using a simple math formula (that you can change to your likings).

The default function used for interpolation is a simple monomial equation of variable degree, but this can be changed however you like. In the `alerting.ini` configuration file, there is a `path_function_script` property which is the relative path to the interpolation script. The default script is located at `precompiler/interpolation_nth_degree.sh`. The given script is provided inputs `A`, `B`, `T`, `N`, `C`. `A` is the start color component. `B` is the end color component. `T` is the moment in the interpolation from `T=0` (where the output should simply be `B`) to `T=100`) where the output should simply be `A`. `N` is an extra argument which is configurable in your `alerting.ini` file; by default, it is used as the degree of the monomial equation. `C` is the color component used: 0 for red, 1 for green, 2 for blue.

Knowing this, you can make your own interpolation script that uses another function. Feel free to PR this repository with your custom functions!

### Precompiler

Once you have your settings all configured to values you like, it is intructed to run the precompiler using `./alerting.sh --precompile`. What does this do? We shall see!

If you script is being ran every n moment and has to compute somewhat complex mathematics, performance will decrease. Since the script should not be called every second, this performance change would probably be unnoticable, but it doesn't require too much setting up so the result is worth it. Instead of doing math, the computer has to look into a table where all values of `T` are shown. The computer only has to look in a table which is basically what computers are made for.

The precompiler runs the provided function script for every value of `T` and puts it into a file whilst respecting a specific format shown in the `segment_repeated` property of the configuration file.

### Main Script

The main script `alerting.sh` allows you to test your settings with 3 commands: `--compile`, `--precompile`, `--run=...`. The `--compile` command simply compiles the precompiler. This does not need to be ran more than once. The `--precompile` command runs the precompiler and generates a script with precompiled values of `T`. The `--run=...` command can be used to test the script at any percentage of battery. Check `--help` for more information about these flags.
